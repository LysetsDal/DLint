{
// ================================================
//          LEXER-GENERATOR SPECIFICATION
// ================================================

open FSharp.Text.Lexing
open System
open DPar
open Utils

(* Read a char and lex it as a string *)
let lexeme (lexbuf: LexBuffer<char>) = 
    LexBuffer<char>.LexemeString lexbuf


let mutable currentPos = 1
let mutable tmpCount = 0

(* Used to parse paths s for the ADD instruction *)
let aPath (idx: int) (s: string) = APATH (idx, (stringToPath s))

(* Used to parse paths s for the COPY and WORKDIR instruction *)
let cPath (idx: int) (s: string) = CPATH (idx, (stringToPath s)) 

(* Used to parse shell commands for the CMD instruction *)
let entrycmd (idx: int) (s: string) = ECMD (idx, (trimWhitespace s))

(* Used to parse key value pairs for the ENV instruction *)
let envVar (idx: int) (s: string) = ENVVAR (idx, (stringToEnvPair s))

(* Used to parse shell commands for the RUN instruction *)
let runcmd (idx: int) (s: string) = RCMD (idx, trimWhitespace s)

(* Used to parse paths s for the COPY and WORKDIR instruction *)
let wPath (idx: int) (s: string) = WPATH (idx, s)

(* Used to parse paths s for the COPY and WORKDIR instruction *)
let mntPt (idx: int) (s: string) = MNTPT (idx, s)

(* Used to parse keywords that dont precede string litereals *)
let keyword (idx: int) (s: string) = 
    match s with 
    | "expose"      -> EXPOSE idx
    | "from"        -> FROM idx
    | "user"        -> USER idx
    | _             -> NAME (idx, s)

}

// Parse an INT
let int = ['0'-'9']
// Parse a letter (including INT and '_')
let letter = ['a'-'z''A'-'Z']['a'-'z''A'-'Z''0'-'9''_']*
// Parse a space a tab or a carriage return 
let whitespace = [' ' '\t' '\r'] 


// RegEx for instructions
let add = "ADD"[' ']+
let cmd = "CMD"[' ']+
let cpath = "COPY"[' ']+
let entrypoint = "ENTRYPOINT"[' ']+ 
let env = "ENV"[' ']+
let run = "RUN"[' ']+ 
let volume = "VOLUME"[' ']+
let wpath = "WORKDIR"[' ']+


rule Token = parse
    | whitespace      { Token lexbuf }
    | '\n'            { lexbuf.EndPos <- lexbuf.EndPos.NextLine; currentPos <- currentPos + 1; Token lexbuf }
    | int+            { INT (System.Int32.Parse (lexeme lexbuf)) }  
    | add             { aPath (currentPos) (Path [] lexbuf)  }
    | cmd             { entrycmd (currentPos) (Shell [] lexbuf) }
    | cpath           { cPath (currentPos) (Path [] lexbuf)  }
    | entrypoint      { entrycmd (currentPos) (Shell [] lexbuf) }
    | env             { envVar (currentPos) (Path [] lexbuf) }
    | run             { runcmd (currentPos) (Shell [] lexbuf) } 
    | volume          { mntPt (currentPos) (Path [] lexbuf)  }
    | wpath           { wPath (currentPos) (Path [] lexbuf)  }
    | letter          { keyword (currentPos) ((lexeme lexbuf).ToLower()) }
    | ':'             { COLON }
    | '.'             { DOT }
    | ','             { COMMA }
    | '='             { EQ }
    | '-'             { DASH }
    | '#'             { EndLineComment lexbuf; currentPos <- currentPos + 1; Token lexbuf }
    | '"'             { CSTST (currentPos, (String [] lexbuf)) }
    | eof             { currentPos <- 1; EOF }
    | _               { currentPos <- 1; failwith "Lexer error: illegal symbol" }

// Parse a single line comment: (# I am a comment)
and EndLineComment = parse
    | '\n'            { lexbuf.EndPos <- lexbuf.EndPos.NextLine; }
    | (eof | '\026')  { currentPos <- 1; () }
    | _               { EndLineComment lexbuf }

// Parse a Path: Terminates on '\n'.
and Path acc = parse
    | [' ']*'\n'[' ']* { currentPos <- currentPos + 1; Microsoft.FSharp.Core.String.concat "" (List.map string (List.rev acc)) }
    | (eof | '\026')   { currentPos <- 1; failwith "Lexer error: unterminated path" }
    | _                { Path (char (lexbuf.LexemeChar 0) :: acc)  lexbuf }

// Parse a shell command: supports multi line with '\'. Terminates on '\n'.
and Shell acc = parse
    | '\\'[' ']*'\n'  { lexbuf.EndPos <- lexbuf.EndPos.NextLine; 
                        currentPos <- currentPos + 1
                        Shell acc lexbuf }
    | '\n'            { currentPos <- currentPos + 1; Microsoft.FSharp.Core.String.concat "" (List.map string (List.rev acc)) }
    | '\t'            { Shell acc lexbuf }
    | (eof | '\026')  { currentPos <- 1; failwith "Lexer error: unterminated shell cmd" }
    | _               { Shell (char (lexbuf.LexemeChar 0) :: acc) lexbuf }

// Parse a Path: Terminates on '"'. Escapes single line quotes with '\'
and String chars = parse 
    | '"' { currentPos <- currentPos + 1; Microsoft.FSharp.Core.String.concat "" (List.map string (List.rev chars)) }
    | "''" { String ('\'' :: chars) lexbuf }    
    | (eof | '\026') { currentPos <- 1; failwith "Lexer error: unterminated string" }
    | ['\000'-'\031' '\127' '\255'] { currentPos <- 1; failwith "Lexer error: invalid character in string" }
    | _ { String (char (lexbuf.LexemeChar 0) :: chars) lexbuf }
