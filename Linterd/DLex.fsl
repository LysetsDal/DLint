{
// ================================================
//          LEXER-GENERATOR SPECIFICATION
// ================================================
open FSharp.Text.Lexing
open System
open DPar
open Utils

(* Read a char and lex it as a string *)
let lexeme (lexbuf: LexBuffer<char>) = 
    LexBuffer<char>.LexemeString lexbuf

let mutable linePos = 1
let mutable tmpCount = 0

(* Used to parse paths s for the ADD instruction *)
let aPath (idx: int) (s: string) = APATH (idx, (stringToPath s))

(* Used to parse paths s for the COPY and WORKDIR instruction *)
let cPath (idx: int) (s: string) = CPATH (idx, (stringToPath s)) 

(* Used to parse shell commands for the CMD instruction *)
let entrycmd (idx: int) (s: string) = ECMD (idx, (trimWhitespace s))

(* Used to parse key value pairs for the ENV instruction *)
let envVar (idx: int) (s: string) = ENVVAR (idx, (stringToEnvPair s))

(* Used to parse shell commands for the RUN instruction *)
let runcmd (idx: int) (s: string) = RCMD (idx, trimWhitespace s)

(* Used to parse paths s for the COPY and WORKDIR instruction *)
let wPath (idx: int) (s: string) = WPATH (idx, s)

(* Used to parse paths s for the COPY and WORKDIR instruction *)
let mntPt (idx: int) (s: string) = MNTPT (idx, s)

(* Used to parse keywords that dont precede string litereals *)
let keyword (idx: int) (s: string) = 
    match s with 
    | "expose"      -> EXPOSE idx
    | "from"        -> FROM idx
    | "user"        -> USER idx
    | _             -> NAME (idx, s)

}

// Parse an INT
let int = ['0'-'9']
// Parse a letter (including INT and '_')
let letter = ['a'-'z''A'-'Z']['a'-'z''A'-'Z''0'-'9''_']*
// Parse a space a tab or a carriage return 
let whitespace = [' ' '\t' '\r'] 

// RegEx for instructions
let add = "ADD"[' ']+
let cmd = "CMD"[' ']+
let cpath = "COPY"[' ']+
let entrypoint = "ENTRYPOINT"[' ']+ 
let env = "ENV"[' ']+
let run = "RUN"[' ']+ 
let volume = "VOLUME"[' ']+
let wpath = "WORKDIR"[' ']+

rule Tokenize = parse
    | whitespace      { Tokenize lexbuf }
    | '\n'            { lexbuf.EndPos <- lexbuf.EndPos.NextLine; 
                        linePos <- linePos + 1; Tokenize lexbuf }
    | int+            { INT (System.Int32.Parse (lexeme lexbuf)) }  
    | add             { aPath (linePos) (Path [] lexbuf)  }
    | cmd             { entrycmd (linePos) (Shell [] lexbuf) }
    | cpath           { cPath (linePos) (Path [] lexbuf)  }
    | entrypoint      { entrycmd (linePos) (Shell [] lexbuf) }
    | env             { envVar (linePos) (Path [] lexbuf) }
    | run             { runcmd (linePos) (Shell [] lexbuf) } 
    | volume          { mntPt (linePos) (Path [] lexbuf)  }
    | wpath           { wPath (linePos) (Path [] lexbuf)  }
    | letter          { keyword (linePos) ((lexeme lexbuf).ToLower()) }
    | ':'             { COLON }
    | '.'             { DOT }
    | ','             { COMMA }
    | '='             { EQ }
    | '-'             { DASH }
    | '#'             { EndLineComment lexbuf; 
                        linePos <- linePos + 1; 
                        Tokenize lexbuf }
    | '"'             { CSTST (linePos, (String [] lexbuf)) }
    | eof             { linePos <- 1; EOF }
    | _               { linePos <- 1; failwith "Lexer error: illegal symbol" }

// Parse a single line comment: (# I am a comment)
and EndLineComment = parse
    | '\n'            { lexbuf.EndPos <- lexbuf.EndPos.NextLine; }
    | (eof | '\026')  { linePos <- 1; () }
    | _               { EndLineComment lexbuf }

// Parse a Path: Terminates on '\n'.
and Path acc = parse
    | [' ']*'\n'[' ']* { linePos <- linePos + 1; 
                         Microsoft.FSharp.Core.String.concat "" (List.map string (List.rev acc)) }
    | (eof | '\026')   { linePos <- 1; failwith "Lexer error: unterminated path" }
    | _                { Path (char (lexbuf.LexemeChar 0) :: acc)  lexbuf }

// Parse a shell command: supports multi line with '\'. Terminates on '\n'.
and Shell acc = parse
    | '\\'[' ']*'\n'  { lexbuf.EndPos <- lexbuf.EndPos.NextLine; 
                        linePos <- linePos + 1
                        Shell acc lexbuf }
    | '\n'            { linePos <- linePos + 1; 
                        Microsoft.FSharp.Core.String.concat "" (List.map string (List.rev acc)) }
    | '\t'            { Shell acc lexbuf }
    | (eof | '\026')  { linePos <- 1; failwith "Lexer error: unterminated shell cmd" }
    | _               { Shell (char (lexbuf.LexemeChar 0) :: acc) lexbuf }

// Parse a Path: Terminates on '"'. Escapes single line quotes with '\'
and String chars = parse 
    | '"'             { linePos <- linePos + 1; 
                        Microsoft.FSharp.Core.String.concat "" (List.map string (List.rev chars)) }
    | "''"            { String ('\'' :: chars) lexbuf }    
    | (eof | '\026')  { linePos <- 1; failwith "Lexer error: unterminated string" }
    | ['\000'-'\031' '\127' '\255'] { linePos <- 1; failwith "Lexer error: invalid character in string" }
    | _               { String (char (lexbuf.LexemeChar 0) :: chars) lexbuf }
